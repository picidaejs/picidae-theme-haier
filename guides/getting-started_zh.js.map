{"version":3,"sources":["webpack:///guides/getting-started_zh.js","webpack:///./test/guides/getting-started_zh.md"],"names":["webpackJsonp","881","module","exports","content","extra"],"mappings":"AAAAA,cAAc,EAAE,KAEVC,IACA,SAAUC,EAAQC,GCFxBD,EAAAC,SACAC,QAAA,mwGACAC","file":"guides/getting-started_zh.js","sourcesContent":["webpackJsonp([8,20],{\n\n/***/ 881:\n/***/ (function(module, exports) {\n\n\t/*markdown-loader*/\n\tmodule.exports = {\n\t  \"content\": \"<div class=\\\"picidae-toc\\\">\\n<ul>\\n<li>\\n<a href=\\\"#yaml-front\\\">Yaml Front</a>\\n</li>\\n<li>\\n<a href=\\\"#%E6%96%87%E4%BB%B6%E8%B7%AF%E7%94%B1%E5%AF%B9%E5%BA%94\\\">文件路由对应</a>\\n</li>\\n</ul>\\n</div>\\n<hr>\\n<p>由于<a href=\\\"/guides/installation_zh\\\">上一节</a>中 picidae 配置文件中将 <code>docRoot</code> 设置为 ./docs，即为 <code>my-docs/docs</code> 目录，那么我们就开始在目录下书写我们的文档吧！\\n首先建立如下结构的文档集合：</p>\\n<pre><code class=\\\"hljs language-text\\\" data-query=\\\"{}\\\" data-lang=\\\"text\\\">docs/\\n├── api/\\n│   ├── __information__<span class=\\\"hljs-selector-class\\\">.md</span>\\n│   ├── hello-haier_zh<span class=\\\"hljs-selector-class\\\">.md</span>\\n│   └── hello-haier<span class=\\\"hljs-selector-class\\\">.md</span>\\n├── help_zh<span class=\\\"hljs-selector-class\\\">.md</span>\\n├── help<span class=\\\"hljs-selector-class\\\">.md</span>\\n├── index_zh<span class=\\\"hljs-selector-class\\\">.md</span>\\n└── index.md</code></pre>\\n<p>那么各文件的对应关系是如何的呢？介绍之前我们现需要了解一下 yaml-front 的文本格式，\\n之前使用过 Hexo 写博客的同学肯定就比较熟悉了，那么可以直接跳过这里了。</p>\\n<h2 id=\\\"yaml-front\\\"><a href=\\\"#yaml-front\\\" aria-hidden=\\\"true\\\"><span class=\\\"icon icon-link\\\"></span></a>Yaml Front</h2>\\n<p>yarm front 意思就是 yaml 前置，那么 yaml 是什么呢？<br>\\nyaml 是一种数据结构的文件格式，如我们需要表达一个 title 为 <code>hello</code> 的数据结构，\\n在 JSON 中是</p>\\n<pre><code class=\\\"hljs language-json\\\" data-query=\\\"{}\\\" data-lang=\\\"json\\\">{ <span class=\\\"hljs-attr\\\">\\\"title\\\"</span>: <span class=\\\"hljs-string\\\">\\\"hello\\\"</span> }</code></pre>\\n<p>而用 yaml 表示则为</p>\\n<pre><code class=\\\"hljs language-yaml\\\" data-query=\\\"{}\\\" data-lang=\\\"yaml\\\"><span class=\\\"hljs-attr\\\">title:</span> <span class=\\\"hljs-string\\\">hello</span></code></pre>\\n<p>除了上面的简单的数据结构以外，yaml 用来表示嵌套复杂的数据结构也是十分给力的！<br>\\n了解 Yaml Front 之后，下面详细介绍各文件的对应关系</p>\\n<h2 id=\\\"文件路由对应\\\"><a href=\\\"#%E6%96%87%E4%BB%B6%E8%B7%AF%E7%94%B1%E5%AF%B9%E5%BA%94\\\" aria-hidden=\\\"true\\\"><span class=\\\"icon icon-link\\\"></span></a>文件路由对应</h2>\\n<p>如下表格：</p>\\n<table>\\n<thead>\\n<tr>\\n<th>文件</th>\\n<th>对应路径</th>\\n<th>描述</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>index.md</td>\\n<td>/</td>\\n<td>英文首页渲染的 md</td>\\n</tr>\\n<tr>\\n<td>index_zh.md</td>\\n<td>/index_zh</td>\\n<td>中文首页</td>\\n</tr>\\n<tr>\\n<td>help.md</td>\\n<td>/help</td>\\n<td>英文帮助页面，支持的 Yaml Front 有 title（用于 document title）</td>\\n</tr>\\n<tr>\\n<td>help_zh.md</td>\\n<td>/help_zh</td>\\n<td>同上逻辑</td>\\n</tr>\\n<tr>\\n<td>api/hello-haier.md</td>\\n<td>/api/hello-haier</td>\\n<td>英文环境下的 API 文档，支持 title（对应页面标题），order（同级排序序号，从小到大）</td>\\n</tr>\\n<tr>\\n<td>api/hello-haier_zh.md</td>\\n<td>/api/hello-haier_zh</td>\\n<td>同上，中文环境</td>\\n</tr>\\n</tbody>\\n</table>\\n<p><strong>注意：</strong> <code>abc.md</code> 不一定对应英文环境，需要看<a href=\\\"/guides/configuration_zh#defaultlang\\\">配置</a>中的 <code>defaultLang</code></p>\\n<p>其中，<code>api/hello-haier.md</code> 中的支持的 yaml-front order 数据，表示的是同级文档下的排序关系，\\n如还存在文档 <code>api/hello-picidae.md</code>，那么页面上渲染的相对顺序是按照 order 来渲染的（从小到大）。</p>\\n<p>噢对了，还有 <code>api/__information__.md</code> 文件，该文件不同于其他 markdown 文档，\\n它是用来控制菜单中的中英文标题，和控制与不同组文档的相对顺序的（从小到大）。</p>\\n<pre><code class=\\\"hljs language-yaml\\\" data-query=\\\"{}\\\" data-lang=\\\"yaml\\\"><span class=\\\"hljs-comment\\\"># api/__information__.md</span>\\n<span class=\\\"hljs-comment\\\"># 英文标题</span>\\n<span class=\\\"hljs-attr\\\">title:</span> <span class=\\\"hljs-string\\\">\\\"Get Stated\\\"</span>\\n<span class=\\\"hljs-comment\\\"># 中文标题</span>\\n<span class=\\\"hljs-attr\\\">title_zh:</span> <span class=\\\"hljs-string\\\">\\\"开始使用\\\"</span>\\n<span class=\\\"hljs-attr\\\">order:</span> <span class=\\\"hljs-number\\\">1</span></code></pre>\\n\",\n\t  \"extra\": {}\n\t}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// guides/getting-started_zh.js","/*markdown-loader*/\nmodule.exports = {\n  \"content\": \"<div class=\\\"picidae-toc\\\">\\n<ul>\\n<li>\\n<a href=\\\"#yaml-front\\\">Yaml Front</a>\\n</li>\\n<li>\\n<a href=\\\"#%E6%96%87%E4%BB%B6%E8%B7%AF%E7%94%B1%E5%AF%B9%E5%BA%94\\\">文件路由对应</a>\\n</li>\\n</ul>\\n</div>\\n<hr>\\n<p>由于<a href=\\\"/guides/installation_zh\\\">上一节</a>中 picidae 配置文件中将 <code>docRoot</code> 设置为 ./docs，即为 <code>my-docs/docs</code> 目录，那么我们就开始在目录下书写我们的文档吧！\\n首先建立如下结构的文档集合：</p>\\n<pre><code class=\\\"hljs language-text\\\" data-query=\\\"{}\\\" data-lang=\\\"text\\\">docs/\\n├── api/\\n│   ├── __information__<span class=\\\"hljs-selector-class\\\">.md</span>\\n│   ├── hello-haier_zh<span class=\\\"hljs-selector-class\\\">.md</span>\\n│   └── hello-haier<span class=\\\"hljs-selector-class\\\">.md</span>\\n├── help_zh<span class=\\\"hljs-selector-class\\\">.md</span>\\n├── help<span class=\\\"hljs-selector-class\\\">.md</span>\\n├── index_zh<span class=\\\"hljs-selector-class\\\">.md</span>\\n└── index.md</code></pre>\\n<p>那么各文件的对应关系是如何的呢？介绍之前我们现需要了解一下 yaml-front 的文本格式，\\n之前使用过 Hexo 写博客的同学肯定就比较熟悉了，那么可以直接跳过这里了。</p>\\n<h2 id=\\\"yaml-front\\\"><a href=\\\"#yaml-front\\\" aria-hidden=\\\"true\\\"><span class=\\\"icon icon-link\\\"></span></a>Yaml Front</h2>\\n<p>yarm front 意思就是 yaml 前置，那么 yaml 是什么呢？<br>\\nyaml 是一种数据结构的文件格式，如我们需要表达一个 title 为 <code>hello</code> 的数据结构，\\n在 JSON 中是</p>\\n<pre><code class=\\\"hljs language-json\\\" data-query=\\\"{}\\\" data-lang=\\\"json\\\">{ <span class=\\\"hljs-attr\\\">\\\"title\\\"</span>: <span class=\\\"hljs-string\\\">\\\"hello\\\"</span> }</code></pre>\\n<p>而用 yaml 表示则为</p>\\n<pre><code class=\\\"hljs language-yaml\\\" data-query=\\\"{}\\\" data-lang=\\\"yaml\\\"><span class=\\\"hljs-attr\\\">title:</span> <span class=\\\"hljs-string\\\">hello</span></code></pre>\\n<p>除了上面的简单的数据结构以外，yaml 用来表示嵌套复杂的数据结构也是十分给力的！<br>\\n了解 Yaml Front 之后，下面详细介绍各文件的对应关系</p>\\n<h2 id=\\\"文件路由对应\\\"><a href=\\\"#%E6%96%87%E4%BB%B6%E8%B7%AF%E7%94%B1%E5%AF%B9%E5%BA%94\\\" aria-hidden=\\\"true\\\"><span class=\\\"icon icon-link\\\"></span></a>文件路由对应</h2>\\n<p>如下表格：</p>\\n<table>\\n<thead>\\n<tr>\\n<th>文件</th>\\n<th>对应路径</th>\\n<th>描述</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>index.md</td>\\n<td>/</td>\\n<td>英文首页渲染的 md</td>\\n</tr>\\n<tr>\\n<td>index_zh.md</td>\\n<td>/index_zh</td>\\n<td>中文首页</td>\\n</tr>\\n<tr>\\n<td>help.md</td>\\n<td>/help</td>\\n<td>英文帮助页面，支持的 Yaml Front 有 title（用于 document title）</td>\\n</tr>\\n<tr>\\n<td>help_zh.md</td>\\n<td>/help_zh</td>\\n<td>同上逻辑</td>\\n</tr>\\n<tr>\\n<td>api/hello-haier.md</td>\\n<td>/api/hello-haier</td>\\n<td>英文环境下的 API 文档，支持 title（对应页面标题），order（同级排序序号，从小到大）</td>\\n</tr>\\n<tr>\\n<td>api/hello-haier_zh.md</td>\\n<td>/api/hello-haier_zh</td>\\n<td>同上，中文环境</td>\\n</tr>\\n</tbody>\\n</table>\\n<p><strong>注意：</strong> <code>abc.md</code> 不一定对应英文环境，需要看<a href=\\\"/guides/configuration_zh#defaultlang\\\">配置</a>中的 <code>defaultLang</code></p>\\n<p>其中，<code>api/hello-haier.md</code> 中的支持的 yaml-front order 数据，表示的是同级文档下的排序关系，\\n如还存在文档 <code>api/hello-picidae.md</code>，那么页面上渲染的相对顺序是按照 order 来渲染的（从小到大）。</p>\\n<p>噢对了，还有 <code>api/__information__.md</code> 文件，该文件不同于其他 markdown 文档，\\n它是用来控制菜单中的中英文标题，和控制与不同组文档的相对顺序的（从小到大）。</p>\\n<pre><code class=\\\"hljs language-yaml\\\" data-query=\\\"{}\\\" data-lang=\\\"yaml\\\"><span class=\\\"hljs-comment\\\"># api/__information__.md</span>\\n<span class=\\\"hljs-comment\\\"># 英文标题</span>\\n<span class=\\\"hljs-attr\\\">title:</span> <span class=\\\"hljs-string\\\">\\\"Get Stated\\\"</span>\\n<span class=\\\"hljs-comment\\\"># 中文标题</span>\\n<span class=\\\"hljs-attr\\\">title_zh:</span> <span class=\\\"hljs-string\\\">\\\"开始使用\\\"</span>\\n<span class=\\\"hljs-attr\\\">order:</span> <span class=\\\"hljs-number\\\">1</span></code></pre>\\n\",\n  \"extra\": {}\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/picidae/lib/lib/loaders/markdown-loader!./test/guides/getting-started_zh.md\n// module id = 881\n// module chunks = 8"],"sourceRoot":""}